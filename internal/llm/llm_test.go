package llm

import (
	"fmt"
	"strings"
	"testing"
	"time"

	"github.com/willis7/prtool/internal/model"
)

func TestStubLLM_Summarise(t *testing.T) {
	tests := []struct {
		name        string
		stub        *StubLLM
		context     string
		expectError bool
		expectedMsg string
	}{
		{
			name:        "default stub returns summary",
			stub:        NewStubLLM(),
			context:     "Test context",
			expectError: false,
			expectedMsg: "This is a summary generated by the stub LLM implementation",
		},
		{
			name:        "custom summary stub",
			stub:        NewStubLLMWithSummary("Custom test summary"),
			context:     "Test context",
			expectError: false,
			expectedMsg: "Custom test summary",
		},
		{
			name:        "error stub returns error",
			stub:        NewStubLLMWithError(fmt.Errorf("API rate limit exceeded")),
			context:     "Test context",
			expectError: true,
			expectedMsg: "API rate limit exceeded",
		},
		{
			name:        "empty context still returns summary",
			stub:        NewStubLLM(),
			context:     "",
			expectError: false,
			expectedMsg: "This is a summary generated by the stub LLM implementation",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := tt.stub.Summarise(tt.context)

			if tt.expectError {
				if err == nil {
					t.Error("Expected error but got none")
				}
				if !strings.Contains(err.Error(), tt.expectedMsg) {
					t.Errorf("Expected error message to contain %q, got %q", tt.expectedMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
				}
				if !strings.Contains(result, tt.expectedMsg) {
					t.Errorf("Expected result to contain %q, got %q", tt.expectedMsg, result)
				}
			}
		})
	}
}

func TestNewStubLLM_Constructors(t *testing.T) {
	t.Run("NewStubLLM creates with default summary", func(t *testing.T) {
		stub := NewStubLLM()
		if stub == nil {
			t.Error("Expected non-nil stub")
		}
		if stub.summary == "" {
			t.Error("Expected default summary to be set")
		}
		if stub.err != nil {
			t.Error("Expected no error in default stub")
		}
	})

	t.Run("NewStubLLMWithSummary creates with custom summary", func(t *testing.T) {
		customSummary := "My custom summary"
		stub := NewStubLLMWithSummary(customSummary)
		if stub.summary != customSummary {
			t.Errorf("Expected custom summary %q, got %q", customSummary, stub.summary)
		}
	})

	t.Run("NewStubLLMWithError creates with error", func(t *testing.T) {
		testError := fmt.Errorf("test error")
		stub := NewStubLLMWithError(testError)
		if stub.err != testError {
			t.Errorf("Expected error %v, got %v", testError, stub.err)
		}
	})
}

func TestBuildContext(t *testing.T) {
	fixedTime := time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC)

	tests := []struct {
		name        string
		prs         []*model.PR
		expected    []string // strings that should be present in the context
		notExpected []string // strings that should NOT be present
	}{
		{
			name: "empty PR list",
			prs:  []*model.PR{},
			expected: []string{
				"No pull requests found for the specified criteria.",
			},
		},
		{
			name: "single PR with all fields",
			prs: []*model.PR{
				{
					Title:      "Add authentication system",
					Author:     "alice-dev",
					Repository: "acme/web-app",
					Number:     123,
					MergedAt:   &fixedTime,
					Labels:     []string{"feature", "security"},
					Body:       "This PR implements OAuth2 authentication with proper error handling and comprehensive tests.",
				},
			},
			expected: []string{
				"Pull Request Summary:",
				"1. Add authentication system",
				"Author: alice-dev",
				"Repository: acme/web-app",
				"Merged: 2024-01-15",
				"Labels: feature, security",
				"Description: This PR implements OAuth2 authentication",
			},
		},
		{
			name: "multiple PRs",
			prs: []*model.PR{
				{
					Title:      "Fix critical bug",
					Author:     "bob-dev",
					Repository: "acme/api",
					Number:     456,
					MergedAt:   &fixedTime,
					Body:       "Fixed a critical bug in the payment processing system.",
				},
				{
					Title:      "Update documentation",
					Author:     "carol-tech-writer",
					Repository: "acme/docs",
					Number:     789,
					MergedAt:   &fixedTime,
					Labels:     []string{"documentation"},
					Body:       "Updated API documentation with new endpoints and examples.",
				},
			},
			expected: []string{
				"1. Fix critical bug",
				"2. Update documentation",
				"Author: bob-dev",
				"Author: carol-tech-writer",
				"Repository: acme/api",
				"Repository: acme/docs",
				"Labels: documentation",
			},
		},
		{
			name: "PR with long description gets truncated",
			prs: []*model.PR{
				{
					Title:      "Major refactoring",
					Author:     "developer",
					Repository: "acme/backend",
					Body:       strings.Repeat("This is a very long description that should be truncated. ", 10) + "This part should not appear.",
				},
			},
			expected: []string{
				"1. Major refactoring",
				"Description: " + strings.Repeat("This is a very long description that should be truncated. ", 3),
				"...",
			},
			notExpected: []string{
				"This part should not appear.",
			},
		},
		{
			name: "PR without merge date or labels",
			prs: []*model.PR{
				{
					Title:      "Work in progress",
					Author:     "dev",
					Repository: "acme/experimental",
					Body:       "Still working on this feature.",
				},
			},
			expected: []string{
				"1. Work in progress",
				"Author: dev",
				"Repository: acme/experimental",
				"Description: Still working on this feature.",
			},
			notExpected: []string{
				"Merged:",
				"Labels:",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := BuildContext(tt.prs)

			// Check expected strings are present
			for _, expected := range tt.expected {
				if !strings.Contains(result, expected) {
					t.Errorf("Expected context to contain %q, but it didn't.\nFull context:\n%s", expected, result)
				}
			}

			// Check that unwanted strings are not present
			for _, notExpected := range tt.notExpected {
				if strings.Contains(result, notExpected) {
					t.Errorf("Expected context NOT to contain %q, but it did.\nFull context:\n%s", notExpected, result)
				}
			}
		})
	}
}

func TestLLMInterface(t *testing.T) {
	// Test that StubLLM implements the LLM interface
	var llm LLM = NewStubLLM()

	context := "Test context for LLM processing"
	summary, err := llm.Summarise(context)

	if err != nil {
		t.Errorf("Unexpected error from LLM interface: %v", err)
	}

	if summary == "" {
		t.Error("Expected non-empty summary from LLM interface")
	}
}

func TestBuildContext_Integration(t *testing.T) {
	// Integration test that builds context from realistic PR data
	// and verifies it's suitable for LLM processing

	mergedTime := time.Date(2024, 1, 10, 14, 30, 0, 0, time.UTC)

	prs := []*model.PR{
		{
			Title:      "Implement user authentication",
			Author:     "security-team",
			Repository: "company/auth-service",
			Number:     100,
			MergedAt:   &mergedTime,
			Labels:     []string{"security", "feature", "high-priority"},
			Body:       "This PR adds OAuth2-based authentication with JWT tokens. Includes comprehensive unit tests, integration tests, and security audits. The implementation follows industry best practices for secure authentication.",
		},
		{
			Title:      "Fix memory leak in data processing",
			Author:     "performance-team",
			Repository: "company/data-processor",
			Number:     200,
			MergedAt:   &mergedTime,
			Labels:     []string{"bugfix", "performance"},
			Body:       "Identified and fixed a memory leak in the batch processing pipeline that was causing OOM errors in production.",
		},
	}

	context := BuildContext(prs)

	// Verify context contains key information
	expectedElements := []string{
		"Pull Request Summary:",
		"user authentication",
		"memory leak",
		"security-team",
		"performance-team",
		"OAuth2-based authentication",
		"memory leak in the batch processing",
		"Merged: 2024-01-10",
		"Labels: security, feature, high-priority",
		"Labels: bugfix, performance",
	}

	for _, element := range expectedElements {
		if !strings.Contains(context, element) {
			t.Errorf("Context missing expected element: %q\nFull context:\n%s", element, context)
		}
	}

	// Verify context is reasonably sized (not too long for LLM processing)
	if len(context) > 5000 {
		t.Errorf("Context is too long (%d chars), might exceed LLM limits", len(context))
	}

	// Verify context is not empty
	if len(context) < 100 {
		t.Errorf("Context is too short (%d chars), might not provide enough information", len(context))
	}
}
