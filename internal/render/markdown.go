package render

import (
	"fmt"
	"strings"
	"time"

	"github.com/willis7/prtool/internal/model"
)

// Metadata contains information about the PR summary generation
type Metadata struct {
	GeneratedAt  time.Time
	Scope        string
	ScopeValue   string
	Since        string
	TotalPRs     int
	Repositories []string
	LLMProvider  string
	LLMModel     string
	Summary      string
}

// Render generates a Markdown document from metadata and PR list
func Render(meta Metadata, prs []*model.PR) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# Pull Request Summary\n\n")

	// Metadata section
	sb.WriteString("## Summary Information\n\n")
	sb.WriteString(fmt.Sprintf("- **Generated At**: %s\n", meta.GeneratedAt.Format("2006-01-02 15:04:05 UTC")))
	sb.WriteString(fmt.Sprintf("- **Scope**: %s (%s)\n", meta.Scope, meta.ScopeValue))
	sb.WriteString(fmt.Sprintf("- **Time Range**: %s\n", meta.Since))
	sb.WriteString(fmt.Sprintf("- **Total PRs**: %d\n", meta.TotalPRs))

	if len(meta.Repositories) > 0 {
		sb.WriteString(fmt.Sprintf("- **Repositories**: %s\n", strings.Join(meta.Repositories, ", ")))
	}

	if meta.LLMProvider != "" {
		sb.WriteString(fmt.Sprintf("- **LLM Provider**: %s", meta.LLMProvider))
		if meta.LLMModel != "" {
			sb.WriteString(fmt.Sprintf(" (%s)", meta.LLMModel))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("\n")

	// LLM Summary section (if available)
	if meta.Summary != "" {
		sb.WriteString("## AI Summary\n\n")
		sb.WriteString(meta.Summary)
		sb.WriteString("\n\n")
	}

	// PR Details section
	if len(prs) > 0 {
		sb.WriteString("## Pull Request Details\n\n")

		for i, pr := range prs {
			sb.WriteString(fmt.Sprintf("### %d. %s\n\n", i+1, pr.Title))

			// Basic info
			sb.WriteString(fmt.Sprintf("- **Author**: %s\n", pr.Author))
			sb.WriteString(fmt.Sprintf("- **Repository**: %s\n", pr.Repository))
			sb.WriteString(fmt.Sprintf("- **PR Number**: #%d\n", pr.Number))

			if pr.MergedAt != nil {
				sb.WriteString(fmt.Sprintf("- **Merged At**: %s\n", pr.MergedAt.Format("2006-01-02 15:04:05")))
			}

			if pr.HTMLURL != "" {
				sb.WriteString(fmt.Sprintf("- **URL**: [View PR](%s)\n", pr.HTMLURL))
			}

			// Labels
			if len(pr.Labels) > 0 {
				sb.WriteString(fmt.Sprintf("- **Labels**: %s\n", strings.Join(pr.Labels, ", ")))
			}

			// Description/Body
			if pr.Body != "" {
				sb.WriteString("\n**Description:**\n\n")
				// Truncate very long descriptions
				body := pr.Body
				if len(body) > 500 {
					body = body[:500] + "..."
				}
				sb.WriteString(body)
				sb.WriteString("\n")
			}

			// Files (if available)
			if len(pr.FilePaths) > 0 {
				sb.WriteString("\n**Modified Files:**\n\n")
				for _, file := range pr.FilePaths {
					sb.WriteString(fmt.Sprintf("- `%s`\n", file))
				}
			}

			sb.WriteString("\n---\n\n")
		}
	} else {
		sb.WriteString("## No Pull Requests Found\n\n")
		sb.WriteString("No pull requests were found for the specified criteria.\n\n")
	}

	// Footer
	sb.WriteString("---\n\n")
	sb.WriteString("*Generated by prtool*\n")

	return sb.String()
}

// RenderTable generates a simple table view of PRs for dry-run mode
func RenderTable(prs []*model.PR) string {
	if len(prs) == 0 {
		return "No pull requests found for the specified criteria.\n"
	}

	var sb strings.Builder

	// Header
	sb.WriteString("Found Pull Requests:\n\n")
	sb.WriteString("| # | Title | Author | Repository | Merged At |\n")
	sb.WriteString("|---|-------|--------|------------|----------|\n")

	// Rows
	for i, pr := range prs {
		title := pr.Title
		if len(title) > 40 {
			title = title[:37] + "..."
		}

		author := pr.Author
		if len(author) > 15 {
			author = author[:12] + "..."
		}

		repository := pr.Repository
		if len(repository) > 20 {
			repository = repository[:17] + "..."
		}

		mergedAt := "N/A"
		if pr.MergedAt != nil {
			mergedAt = pr.MergedAt.Format("2006-01-02")
		}

		sb.WriteString(fmt.Sprintf("| %d | %s | %s | %s | %s |\n",
			i+1, title, author, repository, mergedAt))
	}

	sb.WriteString(fmt.Sprintf("\nTotal: %d pull request(s)\n", len(prs)))

	return sb.String()
}
